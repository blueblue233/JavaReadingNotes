---
title: 4.5 数组类型 数组是引用类型 定义数组 数组的初始化 使用数组
categories: 
  - 疯狂Java讲义 (第4版)
  - 第4章 流酲控制与数组
  - 4.5 数组类型
date: 2020-01-27 11:09:10
updated: 2020-01-28 08:48:18
abbrlink: '71882467'
---
<div id='my_toc'><a href="/JavaReadingNotes/71882467/#4-5-数组类型" class="header_1">4.5 数组类型</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#4-5-1-理解数组-数组也是一种类型" class="header_1">4.5.1 理解数组:数组也是一种类型</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#数组中只能存储一种数据类型的数据" class="header_2">数组中只能存储一种数据类型的数据</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#数组是引用类型" class="header_2">数组是引用类型</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#4-5-2-定义数组" class="header_1">4.5.2 定义数组</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#定义数组时不能指定长度" class="header_2">定义数组时不能指定长度</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#4-5-3-数组的初始化" class="header_1">4.5.3 数组的初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#什么是数组初始化" class="header_2">什么是数组初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#数组元素一旦分配了空间就有了初始值" class="header_2">数组元素一旦分配了空间就有了初始值</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#静态初始化-动态初始化" class="header_2">静态初始化 动态初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#1-静态初始化" class="header_2">1. 静态初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#程序示例-数组静态初始化" class="header_3">程序示例 数组静态初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#静态初始化简写" class="header_3">静态初始化简写</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#使用简写形式比较多" class="header_3">使用简写形式比较多</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#2-动态初始化" class="header_2">2. 动态初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#程序示例-动态初始化" class="header_3">程序示例 动态初始化</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#动态初始化只需要指定数组长度" class="header_3">动态初始化只需要指定数组长度</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#数组动态初始化-默认值" class="header_3">数组动态初始化 默认值</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#静态初始化和动态初始化无法同时使用" class="header_2">静态初始化和动态初始化无法同时使用</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#4-5-4-使用数组" class="header_1">4.5.4 使用数组</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#数组越界" class="header_2">数组越界</a>&nbsp;<br><a href="/JavaReadingNotes/71882467/#length属性" class="header_2">length属性</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
# 4.5 数组类型
数组是编程语言中最常见的一种数据结构,可用于存储多个数据,每个数组元素存放一个数据,通常可通过数组元素的索引来访问数组元素,包括为数组元素赋值和取出数组元素的值。`Java`语言的数组则具有其特有的特征,下面将详细介绍`Java`语言的数组。
# 4.5.1 理解数组:数组也是一种类型
## 数组中只能存储一种数据类型的数据
`Java`的数组要求所有的数组元素具有相同的数据类型。因此,在一个数组中,数组元素的类型是唯一的,即**一个数组里只能存储一种数据类型的数据,而不能存储多种数据类型的数据**。
因为`Java`语言是面向对象的语言,而类与类之间可以支持继承关系,这样可能产生个数组里可以存放多种数据类型的假象。例如有一个水果数组,要求每个数组元素都是水果,实际上数组元素既可以是苹果,也可以是香蕉(苹果、香蕉都继承了水果,都是-种特殊的水果),但这个数组的数组元素的类型还是唯一的,只能是水果类型。
一旦数组的初始化完成,数组在内存中所占的空间将被固定下来,因此数组的长度将不可改变。即使把某个数组元素的数据清空,但它所占的空间依然被保留,依然属于该数组,数组的长度依然不变。
`Java`的数组既可以存储基本类型的数据,也可以存储引用类型的数据,只要所有的数组元素具有相同的类型即可.
## 数组是引用类型
值得指出的是,数组也是一种数据类型,它本身是一种引用类型。例如`int`是一个基本类型,但`int[]`就是一种引用类型了。
# 4.5.2 定义数组
`Java`语言支持两种语法格式来定义数组:
```java
type[] arrayName;
type arrayName[];
```
对这两种语法格式而言,通常推荐使用第一种格式。因为第一种格式不仅具有更好的语意,而且具有更好的可读性。
对于`type[] ArrayName;`方式,很容易理解这是定义一个变量,其中变量名是`arrayName`而变量类型是`type[]`。
前面已经指出:`type[]`确实是一种新类型,与`type`类型完全不同(例如`int`类型是基本类型,但`int[]`是引用类型)。
因此,这种方式既容易理解,也符合定义变量的语法。
但第二种格式`type ArrayName[]`的可读性就差了,看起来好像定义了一个类型为`type`的变量,而变量名是`arrayName`这与真实的含义相去甚远.

类似语言`Java`的C#就不再支持`type arrayName[]`这种语法,它只支持第一种定义数组的语法。越来越多的语言不再支持`type arrayName[]`这种数组定义语法。

## 定义数组时不能指定长度
数组是一种引用类型的变量,因此使用它定义一个变量时,仅仅表示定义了一个引用变量(也就是定义了一个指针),这个引用变量还未指向任何有效的内存,因此**定义数组时不能指定数组的长度**。而且由于定义数组只是定义了一个引用变量,并未指向任何有效的内存空间,所以还没有内存空间来存储数组元素,因此这个数组也不能使用,只有对数组进行初始化后才可以使用。
# 4.5.3 数组的初始化
## 什么是数组初始化
`Java`语言中数组必须先初始化,然后才可以使用。所谓初始化,就是为数组的数组元素分配内存空间,并为每个数组元素赋初始值。
## 数组元素一旦分配了空间就有了初始值
一旦为数组的每个数组元素分配了内存空间,每个内存空间里存储的内容就是该数组元素的值,即使这个内存空间存储的内容是空,这个空也是一个值(`null`)。不管以哪种方式来初始化数组,只要为数组元素分配了内存空间,数组元素就具有了初始值。初始值的获得有两种形式:一种由系统自动分配另一种由程序员指定。

## 静态初始化 动态初始化
数组的初始化有如下两种方式:
- **静态初始化**:**初始化时由程序员显式指定每个数组元素的初始值,由系统决定数组长度**。
- **动态初始化**:**初始化时程序员只指定数组长度,由系统为数组元素分配初始值**。

## 1. 静态初始化
静态初始化的语法格式如下:
```java
arrayName = new type[]{element1, element2,element3,...};
```
在上面的语法格式中,前面的`type`就是**数组元素**的数据类型,此处的`type`必须与定义数组变量时所使用的`type`相同,也可以是定义数组时所指定的`type`的子类,并**使用花括号把所有的数组元素括起来,多个数组元素之间以英文逗号(,)隔开**,定义初始化值的花括号紧跟在之后。
值得指出的是,**执行静态初始化时,显式指定的数组元素值的类型必须与`new`关键字后的`type`类型相同,或者是其子类的实例**。

### 程序示例 数组静态初始化
下面代码定义了使用这三种形式来进行静态初始化。
```java
// 定义一个int数组类型的变量，变量名为intArr.
int[] intArr;
// 使用静态初始化，初始化数组时只指定数组元素的初始值，不指定数组长度。
intArr = new int[] { 5, 6, 8, 20 };

// 定义一个Object数组类型的变量，变量名为objArr.
Object[] objArr;
// 使用静态初始化，初始化数组时数组元素的类型是
// 定义数组时所指定的数组元素类型的子类
objArr = new String[] { "Hello", "World" };

Object[] objArr2;
// 使用静态初始化
objArr2 = new Object[] { "Hello", "World" };
```
因为`Java`语言是面向对象的编程语言,能很好地支持子类和父类的继承关系:子类实例是一种特殊的父类实例。在上面程序中,`String`类型是`Object`类型的子类,即字符串是一种特殊的`Object`实例。
### 静态初始化简写
除此之外,静态初始化还有如下简化的语法格式:
```java
type[] arrayName = {element1, element2, element3,...};
```
在这种语法格式中,直接使用花括号来定义一个数组,花括号把所有的数组元素括起来形成一个数组。**只有在定义数组的同时执行数组初始化才支持使用简化的静态初始化**。
简写形式比规范的动态初始化等号右边少了`new type[]`
### 使用简写形式比较多
在实际开发过程中,可能更习惯将数组定义和数组初始化同时完成,代码如下
```java
// 数组的定义和初始化同时完成，使用简化的静态初始化写法
int[] a = { 5, 6, 7, 9 };
```
## 2. 动态初始化
动态初始化只指定数组的长度,由系统为每个数组元素指定初始值。动态初始化的语法格式如下:
```java
arrayName = new type[length];
```
在上面语法中,需要指定一个`int`类型的`length`参数,这个参数指定了数组的长度,也就是可以容纳数组元素的个数。

与静态初始化相似的是,此处的`type`必须与定义数组时使用的`type`类型相同,或者是定义数组时使用的`type`类型的子类。
### 程序示例 动态初始化
下面代码示范了如何进行动态初始化:
```java
// 数组的定义和初始化同时完成，使用动态初始化语法
int[] prices = new int[5];
// 数组的定义和初始化同时完成，初始化数组时元素的类型是定义数组时元素类型的子类
Object[] books = new String[4];
```
### 动态初始化只需要指定数组长度
执行动态初始化时,程序员只需指定数组的长度,即为每个数组元素指定所需的内存空间,系统将负责为这些数组元素分配初始值。
### 数组动态初始化 默认值
指定初始值时,系统按如下规则分配初始值:
- 数组元素的类型是基本类型中的**整数类型**(`byte`、`short`、`int`和`long`),则数组元素的值是0。
- 数组元素的类型是基本类型中的**浮点类型**(`foat`、`double`),则数组元素的值是0.0
- 数组元素的类型是基本类型中的**字符类型**(`char`),则数组元素的值是`\u00000`
- 数组元素的类型是基本类型中的**布尔类型**(`boolean`),则数组元素的值是`false`
- 数组元素的类型是**引用类型**(类、接口和数组),则数组元素的值是`null`

## 静态初始化和动态初始化无法同时使用
**不要同时使用静态初始化和动态初始化**,也就是说,**不要在进行数组初始化时,既指定数组的长度,也为每个数组元素分配初始值**。
数组初始化完成后,就可以使用数组了,包括为数组元素赋值、访问数组元素值和获得数组长度等。

# 4.5.4 使用数组
数组最常用的用法就是访问数组元素,包括对数组元素进行赋值和取出数组元素的值。访问数组元素都是通过**在数组引用变量后紧跟一个方括号([]),方括号里是数组元素的索引值**,这样就可以访问数组元素了。访问到数组元素后,就可以**把一个数组元素当成一个普通变量使用**了,包括为该变量赋值和取出该变量的值,这个变量的类型就是定义数组时使用的类型。

`Java`语言的数组索引是从0开始的,也就是说,第一个数组元素的索引值为0,最后一个数组元素的索引值为数组长度减1。下面代码示范了输出数组元素的值,以及为指定数组元素赋值:
```java
// 输出objArr数组的第二个元素，将输出字符串"李刚"
System.out.println(objArr[1]);
// 为objArr2的第一个数组元素赋值
objArr2[0] = "Spring";
```
## 数组越界
如果访问数组元素时指定的索引值小于0,或者大于等于数组的长度,编译程序不会出现任何错误但运行时出现异常:`java.lang.ArrayIndexOutofBoundsException:N`(数组索引越界异常),异常信息后的N就是程序员试图访问的数组索引。
下面代码试图访问的数组元素索引值等于数组长度,将引发数组索引越界异常:
```java
// 访问数组元素指定的索引等于数组长度，所以下面代码将在运行时出现异常
System.out.println(objArr2[2]);
```
## length属性
所有的数组都提供了一个`length`属性,通过这个属性可以访问到数组的长度,一旦获得了数组的长度,就可以通过循环来遍历该数组的每个数组元素。

下面代码示范了输出`prices`数组(动态初始化的`int`数组)的每个数组元素的值
```java
// 使用循环输出prices数组的每个数组元素的值
for (int i = 0; i < prices.length; i++) {
    System.out.println(prices[i]);
}
```
执行上面代码将输出5个0,因为`prices`数组执行的是默认初始化,**数组元素是`int`类型,系统为`int`类型的数组元素赋值为0**
下面代码示范了**为动态初始化的数组元素进行赋值**,并通过循环方式输出每个数组元素:
```java
// 对动态初始化后的数组元素进行赋值
books[0] = "Hello";
books[1] = "World";
// 使用循环输出books数组的每个数组元素的值
for (int i = 0; i < books.length; i++) {
    System.out.println(books[i]);
}
```
上面代码将先输出字符串"Hello"和"World",然后输出两个`null`。因为`books`使用了动态初始化,系统为所有数组元素都分配一个`null`作为初始值,后来程序又为前两个元素赋值,所以看到了这样的程序输出结果。
从上面代码中不难看出,初始化一个数组后,相当于同时初始化了多个相同类型的变量,通过数组元素的索引就可以自由访问这些数组元素。使用数组元素与使用普通变量并没有什么不同,一样可以对数组元素进行赋值,或者取出数组元素的值。
