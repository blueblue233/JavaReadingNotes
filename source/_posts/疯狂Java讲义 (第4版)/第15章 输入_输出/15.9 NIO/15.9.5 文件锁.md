---
title: 15.9.5 文件锁
categories: 
  - 疯狂Java讲义 (第4版)
  - 第15章 输入_输出
  - 15.9 NIO
date: 2020-01-06 09:59:23
updated: 2020-01-06 10:31:23
abbrlink: 3b9051b1
---
<div id='my_toc'><a href="/JavaReadingNotes/3b9051b1/#15-9-5-文件锁" class="header_1">15.9.5 文件锁</a>&nbsp;<br><a href="/JavaReadingNotes/3b9051b1/#-lock-方法和-tryLock-方法的区别" class="header_2">`lock`方法和`tryLock`方法的区别</a>&nbsp;<br><a href="/JavaReadingNotes/3b9051b1/#部分锁定" class="header_2">部分锁定</a>&nbsp;<br><a href="/JavaReadingNotes/3b9051b1/#共享锁-排他锁" class="header_2">共享锁 排他锁</a>&nbsp;<br><a href="/JavaReadingNotes/3b9051b1/#释放文件锁" class="header_2">释放文件锁</a>&nbsp;<br><a href="/JavaReadingNotes/3b9051b1/#程序示例" class="header_2">程序示例</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
# 15.9.5 文件锁
文件锁在操作系统中是很平常的事情,如果多个运行的程序需要并发修改同一个文件时,程序之间需要某种机制来进行通信,使用文件锁可以有效地阻止多个进程并发修改同一个文件,所以现在的大部分操作系统都提供了文件锁的功能。
文件锁控制文件的全部或部分字节的访问,但文件锁在不同的操作系统中差别较大,所以早期的`JDK`版本并未提供文件锁的支持。**从`JDK1.4`的`NIO`开始,`Java`开始提供文件锁的支持**。

在`NIO`中,`Java`提供了`FileLock`来支持文件锁定功能,在`FileChannel`中提供的`lock()`和`tryLockO`两个方法可以获得文件锁`FileLock`对象,从而锁定文件。

## `lock`方法和`tryLock`方法的区别
`lock()`和`tryLock()`方法存在区别:
- 当`lock()`试图锁定某个文件时,如果无法得到文件锁,程序将一直阻塞;
- 而`tryLock()`是尝试锁定文件,它将直接返回而不是阻塞,如果获得了文件锁,该方法则返回该文件锁,否则将返回`null`

## 部分锁定
如果`FileChannel`只想锁定文件的部分内容,而不是锁定全部内容,则可以使用如下的`lock()`或`tryLock()`方法。

|方法|描述|
|:--|:--|
|`abstract FileLock tryLock(long position, long size, boolean shared)`|Attempts to acquire a lock on the given region of this channel's file.|
|`abstract FileLock lock(long position, long size, boolean shared)`|Acquires a lock on the given region of this channel's file.|
## 共享锁 排他锁
当参数`shared`为`true`时,表明该锁是一个**共享锁**,它将允许多个进程来读取该文件,但阻止其他进程获得对该文件的排他锁。
当`shared`为`false`时,表明该锁是一个**排他锁**,它将锁住对该文件的读写。
直接使用`lock()`或`tryLock()`方法获取的文件锁是排他锁
程序可以通过调用`FileLock`的`isShared()`方法来判断它获得的锁是否为共享锁。
## 释放文件锁
处理完文件后通过`FileLock`的`release()`方法释放文件锁。
## 程序示例
下面程序示范了使用`FileLock`锁定文件的示例。
```java
import java.io.*;
import java.nio.channels.*;

public class FileLockTest {
	public static void main(String[] args) throws Exception {

		try (
				// 使用FileOutputStream获取FileChannel
				FileChannel channel = new FileOutputStream("a.txt").getChannel()) {
			// 使用非阻塞式方式对指定文件加锁
			FileLock lock = channel.tryLock();
			// 程序暂停10s
			Thread.sleep(10000);
			// 释放锁
			lock.release();
		}
	}
}
```
上面程序中的第一行粗体字代码用于对指定文件加锁,接着程序调用`Thread.sleep(10000)`暂停了10秒后才释放文件锁,因此在这10秒之内,其他程序无法对`a.txt`文件进行修改。
文件锁虽然可以用于控制并发访问,但对于高并发访问的情形,还是推荐使用数据库来保存程序信息,而不是使用文件。

关于文件锁还需要指出如下几点。
- 在某些平台上,文件锁仅仅是建议性的,并不是强制性的。这意味着即使一个程序不能获得文件锁,它也可以对该文件进行读写。
- 在某些平台上,不能同步地锁定一个文件并把它映射到内存中
- 文件锁是由`Java`虚拟机所持有的,如果两个`Java`程序使用同一个`Java`虚拟机运行,则它们不能对同一个文件进行加锁。
- 在某些平台上关闭`FileChannel`时,会释放`Java`虚拟机在该文件上的所有锁,因此应该避免对同一个被锁定的文件打开多个`FileChannel`。

