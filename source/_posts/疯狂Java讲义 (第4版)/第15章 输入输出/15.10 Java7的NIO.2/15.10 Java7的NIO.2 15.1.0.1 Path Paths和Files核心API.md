---
title: 15.10 Java7的NIO.2 15.1.0.1 Path Paths和Files核心API
categories: 
  - 疯狂Java讲义 (第4版)
  - 第15章 输入输出
  - 15.10 Java7的NIO.2
date: 2020-01-06 10:34:37
updated: 2020-02-07 01:34:56
abbrlink: 20b0f64b
---
<div id='my_toc'><a href="/JavaReadingNotes/20b0f64b/#15-10-Java7的NIO-2" class="header_1">15.10 Java7的NIO.2 </a>&nbsp;<br><a href="/JavaReadingNotes/20b0f64b/#15-1-0-1-Path-Paths和Files核心API" class="header_1">15.1.0.1 Path Paths和Files核心API</a>&nbsp;<br><a href="/JavaReadingNotes/20b0f64b/#工具类命名规则" class="header_2">工具类命名规则</a>&nbsp;<br><a href="/JavaReadingNotes/20b0f64b/#程序示例-Path接口" class="header_2">程序示例 Path接口</a>&nbsp;<br><a href="/JavaReadingNotes/20b0f64b/#程序示例-Files工具类" class="header_2">程序示例 Files工具类</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
# 15.10 Java7的NIO.2 
`Java7`对原有的`NIO`进行了重大改进,改进主要包括如下两方面的内容。
- 提供了全面的文件`IO`和文件系统访问支持。
- 基于异步`Channel`的`IO`。

第一个改进表现为`Java7`新增的`java.nio.file`包及各个子包;
第二个改进表现为`Java7`在`java.nio.channels`包下增加了多个以`Asynchronous`开头的`Channel`接口和类。`Java7`把这种改进称为`NIO.2`,本章先详细介绍`NIO`的第二个改进。

# 15.1.0.1 Path Paths和Files核心API
早期的`Java`只提供了一个`File`类来访问文件系统,但`File`类的功能比较有限,它不能利用特定文件系统的特性,`File`所提供的方法的性能也不高。而且,其大多数方法在出错时仅返回失败,并不会提供异常信息
`NIO.2`为了弥补这种不足,引入了一个`Path`接口,**`Path`接口代表一个平台无关的平台路径**。除此之外,`NIO.2`还提供了`Files`、`Paths`两个工具类,其中`Files`包含了大量静态的工具方法来操作文件;`Paths`则包含了两个返回`Path`的静态工厂方法。
## 工具类命名规则
`Files`和`Paths`两个工具类非常符合`Java`一贯的命名风格,比如前面介绍的操作数组的工具类为`Arrays`,操作集合的工具类为`Collections`,这种一致的命名风格可以让读者快速了解这些工具类的用途。
## 程序示例 Path接口
下面程序简单示范了`Path`接口的功能和用法
```java
import java.nio.file.Path;
import java.nio.file.Paths;

public class PathTest {
    public static void main(String[] args) throws Exception {
        // 以当前路径来创建Path对象
        Path path = Paths.get(".");
        System.out.println("path里包含的路径数量：" + path.getNameCount());
        System.out.println("path的根路径：" + path.getRoot());
        // 获取path对应的绝对路径。
        Path absolutePath = path.toAbsolutePath();
        System.out.println(absolutePath);
        // 获取绝对路径的根路径
        System.out.println("absolutePath的根路径：" + absolutePath.getRoot());
        // 获取绝对路径所包含的路径数量
        System.out.println("absolutePath里包含的路径数量：" + absolutePath.getNameCount());
        System.out.println(absolutePath.getName(3));
        // 以多个String来构建Path对象
        Path path2 = Paths.get("g:", "publish", "codes");
        System.out.println(path2);
    }
}
```
从上面程序可以看出,`Paths`提供了`get(String first, String ... more`)方法来获取`Path`对象,`Paths`会将给定的多个字符串连缀成路径,比如`Paths.get("g:","publish","codes")`就返回`g:\publish\codes`路径。

上面程序中的粗体字代码示范了`Path`接口的常用方法,读者可能对`getNameCount()`方法感到有点困惑,此处简要说明一下:
它会返回`Path`路径所包含的路径名的数量,例如`g:\publishl\codes`调用该方法就会返回3。
## 程序示例 Files工具类
`Files`是一个操作文件的工具类,它提供了大量便捷的工具方法,下面程序简单示范了`Files`类的用法。
```java
import java.nio.file.*;
import java.nio.charset.*;
import java.io.*;
import java.util.*;

public class FilesTest {
    public static void main(String[] args) throws Exception {
        // 复制文件
        Files.copy(Paths.get("FilesTest.java"), new FileOutputStream("a.txt"));
        // 判断FilesTest.java文件是否为隐藏文件
        System.out.println("FilesTest.java是否为隐藏文件：" + Files.isHidden(Paths.get("FilesTest.java")));
        // 一次性读取FilesTest.java文件的所有行
        List<String> lines = Files.readAllLines(Paths.get("FilesTest.java"), Charset.forName("gbk"));
        System.out.println(lines);
        // 判断指定文件的大小
        System.out.println("FilesTest.java的大小为：" + Files.size(Paths.get("FilesTest.java")));
        List<String> poem = new ArrayList<>();
        poem.add("水晶潭底银鱼跃");
        poem.add("清徐风中碧竿横");
        // 直接将多个字符串内容写入指定文件中
        Files.write(Paths.get("pome.txt"), poem, Charset.forName("gbk"));
        // 使用Java 8新增的Stream API列出当前目录下所有文件和子目录
        Files.list(Paths.get(".")).forEach(path -> System.out.println(path));
        // 使用Java 8新增的Stream API读取文件内容
        Files.lines(Paths.get("FilesTest.java"), Charset.forName("gbk")).forEach(line -> System.out.println(line));
        FileStore cStore = Files.getFileStore(Paths.get("C:"));
        // 判断C盘的总空间，可用空间
        System.out.println("C:共有空间：" + cStore.getTotalSpace());
        System.out.println("C:可用空间：" + cStore.getUsableSpace());
    }
}
```
上面程序中的粗体字代码简单示范了`Files`工具类的用法。从上面程序不难看出,**`Files`类是一个高度封装的工具类,它提供了大量的工具方法来完成文件复制、读取文件内容、写入文件内容等功能**,这些原本需要程序员通过IO操作才能完成的功能,现在`Files`类只要一个工具方法即可。
`Java8`进一步增强了`Files`工具类的功能,允许开发者使用`Stream API`来操作文件目录和文件内容,上面示例程序中①号代码使用`Stream API`列出了指定路径下的所有文件和目录;②号代码则使用了`Stream API`读取文件内容。

读者应该熟练掌握`Files`工具类的用法,它所包含的工具方法可以大大地简化文件`IO`

