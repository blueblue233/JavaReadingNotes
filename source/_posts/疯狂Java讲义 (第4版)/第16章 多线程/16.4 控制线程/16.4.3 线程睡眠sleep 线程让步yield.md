---
title: 16.4.3 线程睡眠sleep 线程让步yield
categories: 
  - 疯狂Java讲义 (第4版)
  - 第16章 多线程
  - 16.4 控制线程
date: 2019-07-17 13:09:45
updated: 2020-01-08 12:21:12
abbrlink: 2dd1371a
---
<div id='my_toc'><a href="/JavaReadingNotes/2dd1371a/#16-4-3-线程睡眠sleep" class="header_1">16.4.3 线程睡眠sleep</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#sleep方法" class="header_2">sleep方法</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#程序示例-线程sleep" class="header_2">程序示例 线程sleep</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#16-4-4-线程让步-yield" class="header_1">16.4.4 线程让步 yield</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#yield后优先级相同或优先级更高的得到执行机会" class="header_2">yield后优先级相同或优先级更高的得到执行机会</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#程序示例" class="header_2">程序示例</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#yield后低优先级的线程依然有可能得到执行" class="header_2">yield后低优先级的线程依然有可能得到执行</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#sleep方法和yield方法的区别" class="header_2">sleep方法和yield方法的区别</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#yield优先级相关" class="header_3">yield优先级相关</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#sleep先阻塞后就绪-yield直接就绪" class="header_3">sleep先阻塞后就绪 yield直接就绪</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#sleep抛异常-yield不抛异常" class="header_3">sleep抛异常 yield不抛异常</a>&nbsp;<br><a href="/JavaReadingNotes/2dd1371a/#总结" class="header_2">总结</a>&nbsp;<br></div>
<style>.header_1{margin-left: 1em;}.header_2{margin-left: 2em;}.header_3{margin-left: 3em;}.header_4{margin-left: 4em;}.header_5{margin-left: 5em;}.header_6{margin-left: 6em;}</style>
<!--more-->
<script>if (navigator.platform.search('arm')==-1){document.getElementById('my_toc').style.display = 'none';}var e,p = document.getElementsByTagName('p');while (p.length>0) {e = p[0];e.parentElement.removeChild(e);}</script>

<!--end-->
<!--SSTStart-->
# 16.4.3 线程睡眠sleep
## sleep方法
如果需要让当前正在执行的线程暂停一段时间,并进入阻塞状态,则可以通过调用`Thread`类的静态`sleep`方法来实现。 `sleep`方法有两种重载形式。

|方法|描述|
|:---|:---|
|`static void sleep(long millis)`|让当前正在执行的线程暂停`millis`毫秒,并进入阻塞状态,该方法受到系统计时器和线程调度器的精度与准确度的影响。|
|`static void sleep(long millis, int nanos)`|让当前正在执行的线程暂停 `millis`毫秒加 `nanos`毫微秒,并进入阻塞状态,该方法受到系统计时器和线程调度器的精度与准确度的影响。一般很少调用这种形式的`sleep`方法。|

当一个线程调用`sleep`方法进入阻塞状态后,在其睡眠时间段内,该线程不会获得执行的机会,即使系统中没有其他可执行的线程,处于`sleep()`中的线程也不会执行,因此`sleep`方法常用来暂停程序的执行。
<!--SSTStop-->
## 程序示例 线程sleep
下面程序调用`sleep`方法来暂停主线程的执行,因为该程序只有一个主线程,当主线程进入睡眠后,系统没有可执行的线程,所以可以看到程序在`sleep`方法处暂停。
```java
import java.util.*;

public class SleepTest
{
    public static void main(String[] args)
        throws Exception
    {
        for (int i = 0; i < 10 ; i++ )
        {
            System.out.println("当前时间: " + new Date());
            // 调用sleep方法让当前线程暂停1s。
            Thread.sleep(1000);
        }
    }
}
```
运行效果
```cmd
当前时间: Wed Jul 17 13:21:24 CST 2019
当前时间: Wed Jul 17 13:21:25 CST 2019
当前时间: Wed Jul 17 13:21:26 CST 2019
当前时间: Wed Jul 17 13:21:27 CST 2019
当前时间: Wed Jul 17 13:21:28 CST 2019
当前时间: Wed Jul 17 13:21:29 CST 2019
当前时间: Wed Jul 17 13:21:30 CST 2019
当前时间: Wed Jul 17 13:21:31 CST 2019
当前时间: Wed Jul 17 13:21:32 CST 2019
当前时间: Wed Jul 17 13:21:33 CST 2019
```
运行上面程序,看到程序依次输出10条字符串,输出2条字符串之间的时间间隔为1秒。

# 16.4.4 线程让步 yield
`yield`方法是一个和`sleep`方法有点相似的方法,它也是`Thread`类提供的一个静态方法,yield也可以让当前正在执行的线程暂停,但yield不会阻塞该线程,yield只是将该线程转入就绪状态。 **`yield`只是让当前线程暂停一下,让系统的线程调度器重新调度一次**,完全可能的情况是:当某个线程调用了`yield`方法暂停之后,线程调度器又将其调度出来重新执行。
## yield后优先级相同或优先级更高的得到执行机会
实际上,当某个线程调用了`yield`方法暂停之后,**只有优先级与当前线程相同,或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。**
<!--SSTStop-->
## 程序示例
下面程序使用`yield`方法来让当前正在执行的线程暂停。
```java
public class YieldTest extends Thread
{
    public YieldTest(String name)
    {
        super(name);
    }
    // 定义run方法作为线程执行体
    public void run()
    {
        for (int i = 0; i < 50 ; i++ )
        {
            System.out.println(getName() + "  " + i);
            // 当i等于20时，使用yield方法让当前线程让步
            if (i == 20)
            {
                Thread.yield();//代码0
            }
        }
    }
    public static void main(String[] args)throws Exception
    {
        // 启动两条并发线程
        YieldTest yt1 = new YieldTest("高级");
        // 将ty1线程设置成最高优先级
        // yt1.setPriority(Thread.MAX_PRIORITY);//代码1
        yt1.start();
        YieldTest yt2 = new YieldTest("低级");
        // 将yt2线程设置成最低优先级
        // yt2.setPriority(Thread.MIN_PRIORITY);//代码2
        yt2.start();
    }
}
```
上面程序中的代码0调用`yield`静态方法让当前正在执行的线程暂停,让系统线程调度器重新调度。由于程序中代码1、代码2处于注释状态。
此时**`两个线程的优先级完全一样`,所以当一个线程使用`yield`方法后,另一个线程就会开始执行**。运行结果如下所示:
```cmd
...
高级  20
低级  15
...
低级  20
高级  24
...
```
如果将程序中`代码1`和`代码2`的注释取消,也就是为两个线程分别设置不同的优先级,则程序的运行结果如下所示:
```cmd
....
高级  20
低级  10
高级  21
...
高级  49
低级  17
低级  18
低级  19
低级  20
低级  21
...
低级  49
```
## yield后低优先级的线程依然有可能得到执行
线程让步后,由线程调度器选中`就绪状态`中的一个线程来执行,优先级高的线程被选中的机会比较大,但也只是机会大而已,低优先级的线程依然有可能得到运行。
<!--SSTStart-->
## sleep方法和yield方法的区别
关于`sleep`方法和`yield`方法的区别如下:
### yield优先级相关
- `sleep`方法暂停当前线程后,会给其他线程执行机会,不会理会其他线程的优先级;
  - 但`yield`方法只会给`优先级`相同,或优先级更高的线程执行机会。

### sleep先阻塞后就绪 yield直接就绪
- `sleep`方法会将线程转入`阻塞状态`,直到经过阻塞时间才会转入就绪状态;
  - 而`yield`不会将线程转入阻塞状态,它只是强制当前线程进入`就绪状态`。因此完全有可能某个线程调用`yield`方法暂停之后,立即再次获得处理器资源被执行。

### sleep抛异常 yield不抛异常
- `sleep`方法声明抛出了`InterruptedException`异常,所以调用`sleep`方法时要么捕捉该异常,要么显式声明抛出该异常;
  - 而`yiled`方法则没有声明抛出任何异常。
- `sleep`方法比`yiled`方法有更好的可移植性,通常不建议使用`yield`方法来控制并发线程的执行。

## 总结
- `yiled`方法使得线程进入`就绪状态`,系统线程调度器重新调度处于`就绪状态`的一个线程来运行,因为调用`yiled`方法的线程此时也处于`就绪状态`，所以该线程可能被线程调度器选中得以`再次运行`.
- `sleep`方法使得线程进入`阻塞状态`,睡眠时间结束后,再进入`就绪状态`。
<!--SSTStop-->
